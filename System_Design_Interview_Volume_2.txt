+++Chapter 17: Proximity Service

search radius / expand the search
Functional requirements / Non-functional requirements
latitude and longitude pair

LBS: location based service
user privacy / comply with data privacy laws
the spike in traffic during peak hours

API design / Data model (schema design) / High-level design / deep dive into
search results are paginated
reviews / star rating
a new endpoint call to fetch the detailed information

Google Places API: a service that accepts HTTP requests for location data through a variety of methods
read/write ratio / read volume / write volume / infrequent operations

Geospatial indexing is a technique used in databases to efficiently store and retrieve data based on their geographic location
Geohash is a unique identifier of a specific region on the Earth. For a given location on earth, the Geohash algorithm converts its latitude and longitude into a string.

Database cluster can be used for primary-secondary setup
due to replication delay
off-peak hours
different regions and availability zones

geospatial databse such as GeoHash in Redis or PostgreSQL with PostGIS extension
Redis geospatial indexes let you store coordinates and search for them. This data structure is useful for finding nearby points within a given radius or bounding box.

Option 1: Two-dimensional search: not efficient
Option 2: Evenly divided grid: the distribution of business is not even / need more granular grids for dense areas and large grids in sparse areas
Option 3: Geohash: reduce two-dimensional longitude and latitude data into one-dimensional string ofa letters and digits / has 12 precisions (also called levels)
                   only interested in geohashes with lengths between 4 and 6 / edge cases with how the geohash boundary is handled
                   the longer a shared prefix is between two geohashes, the closer they are
                   a common solution is to fetch not nly within the current grid but also from its neighbors

Option 4: Quadtree: (a tree data structure in which each internal node has exactly four children)
                   In memory data structure, not database solution. It doesn't take too much memory and easily fit in one server
                   incrementally rebuild the quadtree, a small subset of servers at a time, across the entire cluster
                   roll out a new release / Blue/green deployment
                   mitigated by setting up a business agreement / update the cache using a nightly job
                   update it on the fly

Option 4: Google S2: a library for spherical geometry / in-memory solution / maps a sphere to 1D index based on Hilbert curve

compound key of (geohash, business_id)
have a series of replicas to help with the read load
a key-value store like Redis
no locking mechanism is needed
fetch fully hydrated business information

------------------------------------------------------------------------------------------------------------------------
+++Chapter 18: Nearby Friends

reasonable assumption / constraints and assumptions
inactive friends
privacy and data laws
occasional data loss
location refresh interval
load more upon request

stateful and bi-directional WebSocket services: each client maintains a persistent WebSocket connection to one of these servers
spread out load evenly
Restful API servers: stateless HTTP servers

Redis location cache: store the most recent location data for active user / Time to Live (TTL)
Redis pub/sub server: lightweight message bus / channels, also called topics
broadcast the update to all the subscribers
Redis provides super-fast read/write operations. It supports TTL used to auto-purge inactive users from the cache.
Redis servers are easily shard based on user id
Redis pub/sub server is used as a routing layer to direct messages

can be horizontal scaled / shard by user id
at a lower scale / increase the scale
inactivity timeout period
minimize downtime
conservative estimation

service discovery: Zookeeper & etcd (A distributed, reliable key-value store for the most critical data of a distributed system)
service discovery is a small key-value store to hold configuration data

consistent hashing / hash ring
over-provisioned / operational overhead and risks
performance hotspots
the incremental load should not overwhelm any single one

nearby random person: a pool of pub/sub by geohash

WebSocket: real-time communication between clients and the servers
Redis: fast read and write of location data
Redis Pub/Sub: routing layer to direct location updates from one user to all the online friends
Redis Pub/Sub implements a real-time messaging system, where publishers, publish to a channel/topic and several clients can subscribe to that channel/topic.

------------------------------------------------------------------------------------------------------------------------
+++Chapter 19: Google Maps

OpenStreetMap
Geocoding is the process of converting addresses to geographic coordicates
Geohashing is an encoding system that encodes a geographic area into a shoet string of letters and digits

Dijkstra's or A* pathfinding algorithms
nodes(intersections) and edges(roads)

rough estimation / server throughput / GPS are batched
analyze user behavior to enable personalization / leverage the location data in near real-time
sent in batch to the server at a lower frequency

communication protocol: HTTP with the keep-alive option
CDN fetches a copy from the origin server, caches it locally and returns it to the user
CDN returns a cached copy without contacting the origin server

keep mobile data usage low / client-side caching
a fast lookup mechanism

cloud storage, Amazon S3
prioritize availability over consistency
partition kay

Kafka: message queue. A unified low-latency, high-throughput data streaming platform designed for real-time data feeds
------------------------------------------------------------------------------------------------------------------------
+++Chapter 20: Distributed Message Queue

systems are broken up into small and independent building blocks with well-defined interfaces between them
Message queues provide communication and coordic=nation for those building blocks

Benefits of message queues:
    - Decoupling: eliminate tight coupling
    - Improved scalability: more consumers are added to handle the increased traffic during peak hours
    - Increased availability: if part of system goes offline, the other continue to interact with queue
    - Better performance: make asynchronous communication easy. Don't need to wait for each other (add to a queue without waiting for response / consume messages whenever they are available)

Apache Kafka (distributed event store and stream-processing platform) / Apache RocketMQ / RabbitMQ / Apache Pulsar / Apache ActiveMQ / ZeroMQ

Kafka and Pulsar are not message queues, but event streaming platform
performant enough

design a distributed message queue with additional features, such as long data retention, repeated comsumption of messages, etc., which are typically only available on event streaming platforms
basic functionality of message queue: producers send messages to a queue, and consumers consume messages from it
other considerations include performance, message delivery semantics (at-most-once, at-least-once, exactly-once), data detention, etc.

Apache Kafka Message Delivery Semantics:
    - At-Most-Once: a message is delivered either one time only or not at all / suitable for monitoring metrics / ack = 0
    - At-Least-Once: a message can be delivered one or more times, but will never be lost. / result in duplicates / suitable for client side which has deduplication / ack = 1 or ack = all
    - Exactly-Once: a  message will always be delivered only one time. / suitable for financial related user cases (payment, accounting and trading) / downstream service doesn't support idempotency

a traditional distributed message queue doesn't retain a message once it has ben successfully delivered to a consumer
a traditional distributed message queue doesn't guarantee delivery orders
a traditional distributed message queue provides on-disk overflow capacity

Messages are measured in the range of KBs
target throughput / end-to-end latency
support a sudden surge in message volume
several orders of magnitude smaller than

producer / consumer / produce / consume / subscribe
message queue is server, and producer/consumer are clients in server/client model

Messaging models:
   - Point-to-point: consumed by only one consumer / There is no data retention in this model
   - Publish-subscribe: implemented by topics

Topics: the categories used to organize messages / each topic has a unique name
Partitions (sharding): a small subset of the messages for a topic
Offset: the position of a message in the partition
Brokers: the servers which hold the partitions
Consumer group: the consumers form a Consumer group for a partition / a set of consumers consume messages from topics together

pull data from these partitions of message queue cluster
a constraint: a single partition can only be consumed by one consumer in the same group

Coordination service: Apache Zookeeper / etcd are used to elect a a controller
send message in batches/ persist messages in even larger batches

Data storage:
   - Option 1: database: database doesn't support read-heavy and write heavy access patterns at a large scale
   - Option 2: Write-ahead-log (WAL). WAL is just a plain file where new entries are appended to an append-only log
               WAL has a pure sequential read/write access pattern. The disk performance of sequential access is good

messages are in transit
cyclic redundancy check (CRC)
routing layer: all messages sent to the routing layer are routed to the correct broker
leader/follower replicas: fault-tolerance

Buffer
   - fewer network hops mean lower latency
   - Batching buffers messages in memory and sends out larger batches in a single request. This increases throughput
The size of batch is a trade-off between throughput and latency

Push vs Pull (most choose pull model)
    push model:
        pros: low latency
        cons: consumers could be overwhelmed
    pull model
        pros: consumers control the consumption rate / can simply scale out the consumers / more suitable for aggressive batch processing
        cons: If there is no message, keeping pulling is wasting resources.

consumer re-balancing / partition dispatch plan / heartbeat

State Storage stores:
   - The mapping between partitions and consumers
   - The last consumed offsets of consumer groups for reach partition
   access pattern for consumer state:
      - Frequent read/write operations but the volume is not high
      - Data is updated frequently and is rarely deletd
      - Random read/write operations
      - Data consistency is important
   A key-value store like Zookeeper is a good choice

Metadata storage stores the configuration and properties of topics, including a number of partitions, retention period, and distribution of replicas
Zookeeper is a good choice for storing metadata (high consistency requirement)

Zookeeper offers a hierarchical kay-value store and used to provide a distributed configuration service, synchronization service, and naming registry
Zookeeper helps with the leader election of broker cluster

Replication is the solution to achieve high availability
replica distribution plan
In-sync replicas (ISR) / committed offset / fully caught up with the leader / lag time / trade-off between performance and durability
acknowledge setting:
    ACK = all: producer get acknowledge after all ISRs received message / the strongest message durability
    ACK = 1: producer get acknowledge once the leader persists message / The latency is improved by not waiting for data synchronization / occasional data loss is acceptable
    ACK = 0: producer keeps sending message without waiting for any acknowledge / lowest latency at the cost of potential data loss / good for collecting metrics or logging data since data volume is high but data loss is acceptable

data mirroring copies data across data centers
server crashes / failure recovery of the brokers / tolerate failure of the node
replicas should not be in the same node
decommissioned partition




------------------------------------------------------------------------------------------------------------------------
+++Chapter 21: Metrics Monitoring and Alerting System

------------------------------------------------------------------------------------------------------------------------
+++Chapter 22: Ad Click Event Aggregation

------------------------------------------------------------------------------------------------------------------------
+++Chapter 23: Hotel Reservation

------------------------------------------------------------------------------------------------------------------------
+++Chapter 24: Distributed Email Service

------------------------------------------------------------------------------------------------------------------------
+++Chapter 25: S3-like Object Storage

------------------------------------------------------------------------------------------------------------------------
+++Chapter 26: Real-time Gaming Leaderboard

------------------------------------------------------------------------------------------------------------------------
+++Chapter 27: Payment System

------------------------------------------------------------------------------------------------------------------------
+++Chapter 28: Digital Wallet

------------------------------------------------------------------------------------------------------------------------
+++Chapter 28: Stock Exchange
