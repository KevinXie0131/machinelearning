building blocks
by some order of magnitude / increases by a factor of ten or more / linearly scale with increasing demands
use off-the-shelf components
strict consistency / strict consistency / durability target / privacy and regulatory requirements
handle ten times more load / be bogged down

Remote procedure calls (RPCs): an interprocess communication protocol / RPC spans the transport and application layers
The responsibilities of RPC runtime also include retransmission, acknowledgment, and encryption
The RPC method is similar to calling a local procedure, except that the called procedure is usually executed in a different process and on a different computer.

Consistency Models:
    Eventual consistency (Weakest consistency) -> Causal consistency -> Sequential consistency -> Strict consistency / linearizability (Strongest consistency)

1. Eventual consistency ensures high availability
2. Causal consistency works by categorizing operations into dependent operations (causally-related operations) and independent operations / cause-and-effect relationship
3. Sequential consistency preserves the ordering specified by each client's program.
4. Strict consistency is the strongest consistency model. synchronous replication is one of the ingredients for achieving strong consistency, though it in itself is not sufficient. We might need consensus algorithms such as Paxos and Raft to achieve strong consistency.
   Linearizability affects the system's availability, which is why it's not always used. Applications with strong consistency requirements use techniques like quorum-based replication to increase the system's availability.

ACID: Atomicity, Consistency, Isolation, and Durability
CAP theorem: Consistency, Availability, and Partition Tolerance

Failure Models:
Fail-stop (Easy to deal with) -> Crash -> Omission failures -> Temporal failures -> Byzantine failures  (Hard to deal with)

Fault tolerance techniques:
    Replication: One of the most widely-used techniques is replication-based fault tolerance
    Checkpointing: a technique that saves the system’s state in stable storage when the system state is consistent
                   When a failure occurs in the system, we can get the last computed data from the previous checkpoint and start working from there.

Application servers primarily provide dynamic content, whereas web servers mostly serve static content to the client, which is mostly a web browser.

commodity servers
a coarse-grained estimation / reasonable upper bounds
incoming data / outgoing data
bandwidth is measured in bits per second

To mitigate this issue, each cached record comes with an expiration time called time-to-live (TTL)

Algorithms of load balancers
    - Round-robin scheduling: a repeating sequential manner
    - Weighted round-robin
    - Least connections
    - Least response time
    - IP hash
    - URL hash

anomalies (like dirty reads, dirty writes, read skew, lost updates, write skew, and phantom reads)
semi-structured and unstructured data / document databases are structureless

NoSQL:
    - Key-value database: Amazon DynamoDB, Redis, and Memcached DB
                          Primary key = Partition key + Sort key
    - Document database: MongoDB and Google Cloud Firestore
                         XML, JSON, BSON / composed of a hierarchical tree data structure
    - Graph database: Neo4J, OrientDB, and InfiniteGraph
    - Columnar database: Cassandra, HBase, Hypertable, and Amazon SimpleDB
                         store data in columns instead of rows
                         efficient for a large number of aggregation and data analytics queries

Drawbacks of NoSQL databases:
    - Lack of standardization
    - Consistency
      We won’t have strong data integrity, like primary and referential integrities in a relational database
      Data might not be strongly consistent but slowly converging using a weak model like eventual consistency

