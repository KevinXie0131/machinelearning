Fallback (provides an alternative solution during a service request failure)
circuit breaker
Sharding key / Partition kay
    - Re-sharding data
    - Celebrity problem
    - Join and de-normalization

support millions of users:
    • Keep web tier stateless
    • Build redundancy at every tier
    • Cache data as much as you can
    • Support multiple data centers
    • Host static assets in CDN
    • Scale your data tier by sharding
    • Split tiers into individual services
    • Monitor your system and use automation tools

sorted by reverse chronological order
fanout service (Fan-out is the distribution of messages by a service or message router to multiple users, often simultaneously)
fanout worker

authentication / rate limiting
roll out the system / a recap of your design
------------------------------------------------------------------------------------------------------------------------
+++Chapter 4: Design A Rate Limiter

throttle rules / rate limiter middleware / malicious actors
API gateway / IP whitelisting
Algorithms for rate limiting
    • Token bucket
        pre-defined capacity
    • Leaking bucket
    • Fixed window counter
    • Sliding window log
    • Sliding window counter

at one minute interval / allows a burst of traffic for short periods
increments the counter by one / reaches the pre-defined threshold
the available quota / remove all the outdated timestamps
rounded up or down

In-memory cache / supports time-based expiration strategy
fetches the counter

two challenges in a distributed environment:
    • Race condition
    • Synchronization issue

gracefully recover from exceptions
------------------------------------------------------------------------------------------------------------------------
+++Chapter 5: Design Consistent Hashing

Consistent hashing (hash ring / virtual nodes or replicas / redistributed.)
mitigate this problem
------------------------------------------------------------------------------------------------------------------------
+++Chapter 6: Design A Key-value Store

Automatic scaling
due to the space constraint
stale data
Data partition / Data replication / Write path / Read path

Data partition
    • Distribute data across multiple servers evenly.
    • Minimize data movement when nodes are added or removed.

Quorum consensus
    Data replication can guarantee consistency for both read and write operations
    If W + R > N, strong consistency is guaranteed because there must be at least one overlapping node that has the latest data to ensure consistency.
        N = The number of replicas
        W = A write quorum of size W
        R = A read quorum of size R

Consistency models:
    • Strong consistency (usually achieved by forcing a replica not to accept new reads/writes until every replica has agreed on current write)
    • Weak consistency
    • Eventual consistency (this is a specific form of weak consistency. Given enough time, all updates are propagated, and all replicas are consistent.)

    Dynamo and Cassandra adopt eventual consistency, which is our recommended consistency model for our key-value store.

Inconsistency resolution: versioning / vector locks
    detect conflicts and reconcile conflicts
    A vector clock is a [server, version] pair associated with a data item

Failure detection
    gossip protocol (decentralized failure detection methods) - node membership list / heartbeat counter

Handling temporary failures
    'sloppy quorum' is used to improve availability (chooses the first W healthy servers for writes and first R healthy servers for reads on the hash ring. Offline servers are ignored)
    hinted handoff (Since s2 is unavailable, reads and writes will be handled by s3 temporarily. When s2 comes back online, s3 will hand the data back to s2)

Handling permanent failures
    anti-entropy protocol
    A hash tree or Merkle tree is used for inconsistency detection and minimizing the amount of data transferred

Bloom filter
------------------------------------------------------------------------------------------------------------------------
+++Chapter 7: Design A Unique Id Generator In Distributed Systems

generate unique IDs in distributed systems
    • Multi-master replication: database auto_increment feature
    • Universally unique identifier (UUID)
    • Ticket server: centralized auto_increment feature in a single database server (Ticket Server)
    • Twitter snowflake approach

a few additional talking points:
    • Clock synchronization - Network Time Protocol
    • Section length tuning
    • High availability - mission-critical
------------------------------------------------------------------------------------------------------------------------
+++Chapter 8: Design A Url Shortener

REST-style APIs / restful API / HTTP redirection / URL redirecting
301 Moved Permanently redirect status response code

301 redirect vs 302 redirect
    - 301 redirect: the browser caches the response, and subsequent requests for the same URL will not be sent to the URL shortening service
    - 302 redirect: subsequent requests for the same URL will be sent to the URL shortening service first

[0-9, a-z, A-Z], containing 10 + 26 + 26 = 62 possible characters.

two types of hash functions for a URL shortener:
    - Hash + collision resolution / bloom filters (a space-efficient probabilistic technique to test if an element is a member of a set.)
    - base 62 conversion
         base 62 is a way of using 62 characters for encoding. The mappings are:
         0-0, ..., 9-9, 10-a, 11-b, ..., 35-z, 36-A, ..., 61-Z, where ‘a’ stands for 10, ‘Z’ stands for 61, etc.

additional talking points:
   • Rate limiter - malicious users / overwhelmingly large number of URL shortening requests
   • Web server scaling - web tier is stateless
   • Database scaling - Database replication and sharding
   • Integrating an analytics solution
   • Availability, consistency, and reliability
------------------------------------------------------------------------------------------------------------------------
+++Chapter 9: Design A Web Crawler

A crawler is used for many purposes:
   • Search engine indexing
   • Web archiving
   • Web mining
   • Web monitoring

with duplicate content
the following characteristics:
   • Scalability
   • Robustness
   • Extensibility
Peak QPS = 2 * QPS

Seed URLs / URL Frontier / DNS Resolver / HTML Downloader / Content Parser / Content Seen? / Content Storage / URL Extractor / URL Filter / URL Seen? / URL Storage
potential infinite loops

Depth-first search (DFS) vs Breadth-first search (BFS)
prioritize URLs according to their page ranks, web traffic, update frequency, etc.

Politeness - denial-of-service (DOS) attack
Priority - measured by PageRank [10], website traffic, update frequency, etc.
Freshness - A web crawler must periodically re-crawl downloaded pages to keep our data set fresh.

Robots.txt called Robots Exclusion Protocol

performance optimizations for HTML downloader
    1. Distributed crawl
    2. Cache DNS Resolver - updated periodically by cron jobs
    3. Locality - Distribute crawl servers geographically
    4. Short timeout

Robustness - handle exceptions gracefully without crashing the system
Extensibility - can be extended by plugging in new modules

1. Redundant content - Hashes or checksums help to detect duplication
2. Spider traps - infinite loop
3. Data noise - advertisements, code snippets, spam URLs, etc.

relevant talking points:
   • Server-side rendering - generate links on the fly / retrieve dynamically generated links / server-side rendering (also called dynamic rendering) first before parsing a page
   • Filter out unwanted pages
   • Database replication and sharding - improve the data layer availability, scalability, and reliability.
   • Horizontal scaling - The key is to keep servers stateless
   • Availability, consistency, and reliability
   • Analytics - data is key ingredient for fine-tuning

------------------------------------------------------------------------------------------------------------------------
+++Chapter 10: Design A Notification System

Three types of notification formats: mobile push notification / SMS message / Email
soft real-time system / slight delay is acceptable
able to opt-out / opt-in
mobile device tokens

iOS push notification - Apple Push Notification Service (APNS)
Android push notification - Firebase Cloud Messaging (FCM)
SMS message - third party SMS services like Twilio, Nexmo
Email - Sendgrid, Mailchimp

easily plugging or unplugging of a third-party service
set up automatic horizontal scaling
Introduce message queues to decouple the system components / Message queues serve as buffers when high volumes of notifications

fetch metadata such as setting from the cache or database / Workers pull notification events from message queues

• Reliability
    persists notification data in a database and implements a retry mechanism

Notification setting (fine-grained control) / rate limiting / retry mechanism / event tracking (Notification metrics. Analytics service implements events tracking) / authentication (AppKey/appSecret pair)

------------------------------------------------------------------------------------------------------------------------
+++Chapter 11: Design A News Feed System

sorted by reverse chronological order or any particular order / built by aggregating friends' posts in reverse chronological order
DAU (Daily Active Users)

Fanout service -> Message Queue -> Fanout Workers
Two types of fanout models:
    Fanout on write (also called push model) - news feed is pre-computed during write time
                                               A new post is delivered to friends' cache immediately after it is published
                                               hotkey problem
    Fanout on read (also called pull model) - news feed is generated during read time
                                              on-demand model
    hybrid approach
       For celebrities or users who have many friends/followers, we let followers pull news content on-demand to avoid system overload
       Consistent hashing is a useful technique to mitigate the hotkey problem

Graph databases are suited for managing friend relationship and friend recommendations

Cache architecture / divide the cache tier into 5 layers
   • News Feed: It stores IDs of news feeds.
   • Content: It stores every post data. Popular content is stored in hot cache.
   • Social Graph: It stores user relationship data.
   • Action: It stores info about whether a user liked a post, replied a post, or took other actions on a post.
   • Counters: It stores counters for like, reply, follower, following, etc.

Scaling the database:
    • Vertical scaling vs Horizontal scaling
    • SQL vs NoSQL
    • Master-slave replication
    • Read replicas
    • Consistency models
    • Database sharding
Other talking points:
    • Keep web tier stateless
    • Cache data as much as you can
    • Support multiple data centers
    • Lose couple components with message queues
    • Monitor key metrics. For instance, QPS during peak hours and latency while users refreshing their news feed are interesting to monitor

------------------------------------------------------------------------------------------------------------------------
+++Chapter 12: Design A Chat System




------------------------------------------------------------------------------------------------------------------------
+++Chapter 13: Design A Search Autocomplete System

------------------------------------------------------------------------------------------------------------------------
+++Chapter 14: Design Youtube

------------------------------------------------------------------------------------------------------------------------
+++Chapter 15: Design Google Drive








